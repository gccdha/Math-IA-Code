a = [[0, 0, 0, 0, 0, 216, 0, 0, 94, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 396, 0, 0, 0, 0, 0, 0, 0, 371, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 324, 0, 0, 0, 408, 0, 0, 0, 288],
     [0, 0, 0, 0, 0, 0, 0, 0, 156, 0, 662, 0, 0, 0, 0, 0, 0, 349, 0, 0],
     [0, 396, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 651, 0],
     [216, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 251, 0, 0, 0, 0, 0, 0, 0, 0, 777, 0, 0, 651],
     [0, 0, 0, 0, 0, 0, 251, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [94, 0, 0, 156, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 195, 0, 0, 0, 0, 0],
     [0, 0, 0, 662, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 453, 0, 0, 0, 0, 570],
     [0, 0, 324, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 199, 0, 0],
     [0, 371, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 857, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1656, 0, 0, 167, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 195, 453, 0, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 408, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1656, 0, 0, 932, 0, 0, 543],
     [0, 0, 0, 0, 0, 0, 780, 0, 0, 0, 0, 0, 860, 0, 0, 932, 0, 0, 0, 0],
     [0, 0, 0, 349, 0, 0, 0, 0, 0, 0, 0, 199, 0, 0, 0, 0, 0, 0, 0, 0],
     [0, 0, 0, 0, 651, 0, 0, 0, 0, 0, 0, 0, 0, 166, 0, 0, 0, 0, 0, 0],
     [0, 0, 288, 0, 0, 0, 650, 0, 0, 0, 570, 0, 0, 0, 0, 542, 0, 0, 0, 0]]

b = [[0, 2802, 805, 242, 2902, 216, 1559, 1632, 94, 1259, 867, 651, 2420, 2852, 1072, 1197, 1796, 462, 2896, 967],
     [2802, 0, 2010, 2633, 396, 2996, 1439, 1559, 2723, 2694, 2197, 2321, 371, 1149, 2521, 1937, 1045, 2350, 992, 1846],
     [805, 2009, 0, 692, 2110, 998, 915, 1055, 774, 1346, 722, 324, 1742, 2063, 1172, 409, 1003, 353, 2103, 288],
     [241, 2636, 691, 0, 2789, 454, 1338, 1411, 156, 1054, 662, 538, 2266, 2739, 867, 1084, 1625, 349, 2782, 812],
     [2906, 396, 2114, 2794, 0, 3100, 1734, 1932, 2875, 3000, 2485, 2426, 745, 808, 2827, 1977, 1287, 2455, 651, 2037],
     [215, 2995, 998, 456, 3095, 0, 1780, 1853, 309, 1473, 1081, 699, 2661, 3045, 1286, 1391, 1989, 653, 3089, 1208],
     [1560, 1438, 915, 1337, 1733, 1781, 0, 251, 1480, 1277, 795, 1235, 1073, 2108, 1104, 993, 777, 1181, 2036, 651],
     [1635, 1558, 1058, 1411, 1933, 1855, 251, 0, 1554, 1147, 807, 1344, 1193, 2348, 974, 1186, 1018, 1290, 2276, 802],
     [94, 2725, 774, 155, 2871, 307, 1479, 1552, 0, 1172, 780, 620, 2356, 2821, 985, 1167, 1715, 431, 2865, 902],
     [1258, 2693, 1347, 1055, 2995, 1470, 1273, 1147, 1172, 0, 626, 1375, 2328, 3250, 195, 1746, 2004, 1226, 3214,
      1195],
     [865, 2199, 723, 662, 2485, 1078, 795, 808, 779, 626, 0, 750, 1862, 2625, 453, 1122, 1380, 689, 2589, 570],
     [651, 2325, 328, 538, 2425, 699, 1238, 1347, 620, 1375, 751, 0, 2050, 2376, 1202, 721, 1319, 199, 2419, 583],
     [2421, 369, 1741, 2263, 745, 2661, 1073, 1192, 2354, 2328, 1862, 2033, 0, 1390, 2154, 1654, 857, 2015, 1255, 1476],
     [2852, 1150, 2063, 2739, 808, 3046, 2114, 2355, 2821, 3251, 2627, 2377, 1406, 0, 3078, 1656, 1340, 2400, 167,
      2067],
     [1071, 2519, 1174, 868, 2821, 1284, 1099, 973, 985, 195, 453, 1201, 2154, 3076, 0, 1573, 1831, 1039, 3040, 1021],
     [1196, 1938, 408, 1084, 1973, 1390, 992, 1183, 1165, 1745, 1121, 721, 1653, 1656, 1571, 0, 932, 745, 1732, 543],
     [1795, 1048, 1003, 1622, 1270, 1989, 780, 1021, 1712, 2001, 1377, 1314, 860, 1336, 1828, 930, 0, 1343, 1264, 817],
     [461, 2350, 353, 349, 2450, 653, 1183, 1291, 430, 1225, 690, 199, 2015, 2400, 1038, 746, 1344, 0, 2444, 562],
     [2897, 993, 2105, 2784, 651, 3090, 2052, 2292, 2866, 3211, 2587, 2416, 1263, 166, 3038, 1730, 1277, 2445, 0, 2027],
     [969, 1847, 289, 811, 2034, 1208, 650, 799, 901, 1193, 570, 581, 1477, 2064, 1020, 542, 818, 563, 2028, 0]]


def list_cyc(list):
    transformer = []
    for x in range(len(list)):
        if x == len(list) - 1:
            transformer.append(0)
        else:
            transformer.append(x + 1)
    return [list[i] for i in transformer]

# <This code is contributed by Divyanshu Mehta>
# Python program for Dijkstra's single
# source shortest path algorithm. The program is
# for adjacency matrix representation of the graph


class Graph():

    def __init__(self, vertices):
        self.V = vertices
        self.graph = [[0 for column in range(vertices)]
                      for row in range(vertices)]

    def printSolution(self, dist):
        print("Vertex tDistance from Source")
        for node in range(self.V):
            print(node, "t", dist[node])

    # A utility function to find the vertex with
    # minimum distance value, from the set of vertices
    # not yet included in shortest path tree
    def minDistance(self, dist, sptSet):

        # Initialize minimum distance for next node
        min = 1e7
        min_index = 0
        # Search not nearest vertex not in the
        # shortest path tree
        for v in range(self.V):
            if dist[v] < min and sptSet[v] == False:
                min = dist[v]
                min_index = v
        print(min_index)
        return min_index

    # Function that implements Dijkstra's single source
    # shortest path algorithm for a graph represented
    # using adjacency matrix representation
    def dijkstra(self, src):

        dist = [1e7] * self.V
        dist[src] = 0
        sptSet = [False] * self.V

        for cout in range(self.V):

            # Pick the minimum distance vertex from
            # the set of vertices not yet processed.
            # u is always equal to src in first iteration
            u = self.minDistance(dist, sptSet)

            # Put the minimum distance vertex in the
            # shortest path tree
            sptSet[u] = True

            # Update dist value of the adjacent vertices
            # of the picked vertex only if the current
            # distance is greater than new distance and
            # the vertex in not in the shortest path tree
            for v in range(self.V):
                if (self.graph[u][v] > 0 and
                        sptSet[v] == False and
                        dist[v] > dist[u] + self.graph[u][v]):
                    dist[v] = dist[u] + self.graph[u][v]

        self.printSolution(dist)
        return dist


# Driver program
g = Graph(20)
g.graph = a

"""[[0, 4, 0, 0, 0, 0, 0, 8, 0],
           [4, 0, 8, 0, 0, 0, 0, 11, 0],
           [0, 8, 0, 7, 0, 4, 0, 0, 2],
           [0, 0, 7, 0, 9, 14, 0, 0, 0],
           [0, 0, 0, 9, 0, 10, 0, 0, 0],
           [0, 0, 4, 14, 10, 0, 2, 0, 0],
           [0, 0, 0, 0, 0, 2, 0, 1, 6],
           [8, 11, 0, 0, 0, 0, 1, 0, 7],
           [0, 0, 2, 0, 0, 0, 6, 7, 0]
           ]"""
# </This code is contributed by Divyanshu Mehta>

total_distances = []
for x in a:
    total_distances.append(g.dijkstra(0))
    for c, y in enumerate(a):
        a[c] = list_cyc(y)
    a = list_cyc(a)
    print(a)
    g.graph = a

for cx, x in enumerate(total_distances):
    c = x
    for y in range(len(total_distances)-cx):
        c = list_cyc(c)
    total_distances[cx] = c
print(total_distances)

percents = []
for y in range(len(total_distances)):
    percents.append([])

    for x in range(len(total_distances[y])):
        try:
            percents[y].append(total_distances[y][x] / b[y][x])
        except ZeroDivisionError:
            percents[y].append(0)
d = []
for cx, x in enumerate(percents):
    for cy, y in enumerate(x):
        if y > 1.75:
            d.append([cx, cy, y])
            print(f"{cx},{cy}:    {y}\n")

print(d)
out = [0, 0, 0]
for x in d:
    if x[2] > out[2]:
        out = x
print(out)